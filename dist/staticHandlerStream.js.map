{"version":3,"sources":["../src/staticHandlerStream.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport type { BunnyAdapterOptions, BunnyResolutionsResponse, BunnyVideoMeta } from './types.js'\n\nexport const streamStaticHandler = async (\n  req: PayloadRequest,\n  stream: NonNullable<BunnyAdapterOptions['stream']>,\n  {\n    collection,\n    docId,\n    videoId,\n    videoMeta,\n  }: {\n    collection: string\n    docId: number | string\n    videoId: string\n    videoMeta: BunnyVideoMeta | null\n  },\n): Promise<Response> => {\n  const fallbackEnabled = stream.mp4Fallback?.enabled || !!stream.mp4FallbackQuality\n\n  if (!fallbackEnabled) {\n    return new Response('MP4 fallback not configured.', { status: 400 })\n  }\n\n  let fallbackQuality: string | undefined = undefined\n  let availableResolutions: string[] = []\n  let metaNeedsUpdate = false\n\n  if (videoMeta && typeof videoMeta === 'object' && 'highestMp4Resolution' in videoMeta && videoMeta.highestMp4Resolution) {\n    const savedResolutionUrl = `https://${stream.hostname}/${videoId}/play_${videoMeta.highestMp4Resolution}.mp4`\n\n    try {\n      const headResponse = await fetch(savedResolutionUrl, {\n        headers: { 'Accept': 'video/mp4' },\n        method: 'HEAD',\n      })\n\n      if (headResponse.ok) {\n        fallbackQuality = videoMeta.highestMp4Resolution\n\n        if (videoMeta.availableMp4Resolutions && videoMeta.availableMp4Resolutions.length > 0) {\n          availableResolutions = videoMeta.availableMp4Resolutions\n        }\n      } else {\n        metaNeedsUpdate = true\n      }\n    } catch (error) {\n      req.payload.logger.error(`Error checking saved resolution: ${error instanceof Error ? error.message : String(error)}`)\n      metaNeedsUpdate = true\n    }\n  } else {\n    metaNeedsUpdate = true\n  }\n\n  if (!fallbackQuality) {\n    try {\n      const resolutionsUrl = `https://video.bunnycdn.com/library/${stream.libraryId}/videos/${videoId}/resolutions`\n      const resolutionsResponse = await fetch(resolutionsUrl, {\n        headers: {\n          'Accept': 'application/json',\n          'AccessKey': stream.apiKey || '',\n        },\n      })\n\n      if (resolutionsResponse.ok) {\n        const resolutionsData = await resolutionsResponse.json() as BunnyResolutionsResponse\n\n        if (resolutionsData.success && resolutionsData.data.mp4Resolutions.length > 0) {\n          availableResolutions = resolutionsData.data.mp4Resolutions.map(r => r.resolution)\n\n          if (availableResolutions.length > 0) {\n            const sortedResolutions = [...availableResolutions].sort((a, b) =>\n              parseInt(b.replace('p', '')) - parseInt(a.replace('p', '')),\n            )\n\n            for (const resolution of sortedResolutions) {\n              const checkUrl = `https://${stream.hostname}/${videoId}/play_${resolution}.mp4`\n              try {\n                const headResponse = await fetch(checkUrl, {\n                  headers: { 'Accept': 'video/mp4' },\n                  method: 'HEAD',\n                })\n\n                if (headResponse.ok) {\n                  fallbackQuality = resolution\n                  break\n                }\n              } catch (error) {\n                req.payload.logger.error(`Error checking resolution ${resolution}: ${error instanceof Error ? error.message : String(error)}`)\n              }\n            }\n\n            if (fallbackQuality) {\n              metaNeedsUpdate = !videoMeta ||\n                !videoMeta.highestMp4Resolution ||\n                videoMeta.highestMp4Resolution !== fallbackQuality\n            }\n          }\n        } else {\n          req.payload.logger.error('No MP4 resolutions available from Bunny API')\n        }\n      } else {\n        req.payload.logger.error(`Failed to fetch available resolutions: ${resolutionsResponse.status}`)\n      }\n    } catch (error) {\n      req.payload.logger.error(`Error fetching available resolutions: ${error instanceof Error ? error.message : String(error)}`)\n    }\n  }\n\n  if (!fallbackQuality) {\n    return new Response('Could not determine a valid resolution for the video', { status: 404 })\n  }\n\n  if (metaNeedsUpdate && fallbackQuality && docId && collection) {\n    try {\n      await req.payload.update({\n        id: docId,\n        collection,\n        data: {\n          bunnyVideoMeta: {\n            availableMp4Resolutions: availableResolutions.length > 0 ? availableResolutions : undefined,\n            highestMp4Resolution: fallbackQuality,\n          },\n        },\n      })\n    } catch (error) {\n      req.payload.logger.error(`Failed to update bunnyVideoMeta: ${error instanceof Error ? error.message : String(error)}`)\n    }\n  }\n\n  const rangeHeader = req.headers.get('range')\n  const requestHeaders = new Headers()\n  if (rangeHeader) {\n    requestHeaders.set('Range', rangeHeader)\n  }\n\n  const mp4Url = `https://${stream.hostname}/${videoId}/play_${fallbackQuality}.mp4`\n\n  const response = await fetch(mp4Url, {\n    headers: requestHeaders,\n  })\n\n  if (!response.ok && response.status !== 206) {\n    return new Response(null, { status: 404, statusText: 'Not Found' })\n  }\n\n  const responseHeaders = new Headers()\n  response.headers.forEach((value, key) => {\n    responseHeaders.set(key, value)\n  })\n\n  if (!responseHeaders.has('content-type')) {\n    responseHeaders.set('content-type', 'video/mp4')\n  }\n\n  return new Response(response.body, {\n    headers: responseHeaders,\n    status: response.status,\n  })\n}"],"names":["streamStaticHandler","req","stream","collection","docId","videoId","videoMeta","fallbackEnabled","mp4Fallback","enabled","mp4FallbackQuality","Response","status","fallbackQuality","undefined","availableResolutions","metaNeedsUpdate","highestMp4Resolution","savedResolutionUrl","hostname","headResponse","fetch","headers","method","ok","availableMp4Resolutions","length","error","payload","logger","Error","message","String","resolutionsUrl","libraryId","resolutionsResponse","apiKey","resolutionsData","json","success","data","mp4Resolutions","map","r","resolution","sortedResolutions","sort","a","b","parseInt","replace","checkUrl","update","id","bunnyVideoMeta","rangeHeader","get","requestHeaders","Headers","set","mp4Url","response","statusText","responseHeaders","forEach","value","key","has","body"],"mappings":"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"}